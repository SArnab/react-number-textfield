{"version":3,"sources":["webpack://ReactNumberTextfield/webpack/universalModuleDefinition","webpack://ReactNumberTextfield/webpack/bootstrap","webpack://ReactNumberTextfield/external \"react\"","webpack://ReactNumberTextfield/./src/NumberTextfield.tsx"],"names":["root","factory","exports","module","require","define","amd","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","initialState","string_value","NumberTextfield_NumberTextfield","external_react_","[object Object]","props","charCode","super","this","state","handleKeyPress","e","shouldCancel","String","fromCharCode","decimal_character","precision","indexOf","preventDefault","stopPropagation","handleChange","parseResult","parseString","target","group_separator","setState","didChangeNumber","number_value","Error","nextProps","currState","number","toString","type","className","placeholder","onKeyPress","onChange","decimalChar","groupChar","maxPrecision","sanitzeRegExp","RegExp","str","replace","stringValue","numberValue","undefined","isDecimal","length","parseFloat","parseInt","stringToNumber","isNaN","console","warn","stringParts","split","countDecimalPrecision","roundingConstant","Math","pow","floor","stringValueParts","integerString","decimalString","numGroups","formattedString","substr","integerRemainder","Array","fill","join","numberToString","max","min","defaultProps"],"mappings":"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","file":"react-number-textfield.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ReactNumberTextfield\", [\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactNumberTextfield\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactNumberTextfield\"] = factory(root[\"react\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import * as React from \"react\";\n\ninterface IProps {\n\t/**\n\t * Initial number value to display in the textfield.\n\t * @type {number}\n\t */\n\tnumber?: number;\n\n\t/**\n\t * The character used to separate the decimal parts from the whole number.\n\t * This is usually a comma or a dot.\n\t * @type {string}\n\t */\n\tdecimal_character: string;\n\n\t/**\n\t * The character used to separate a group of digits in the number.\n\t * This is done every 3 (thousand) values.\n\t * @type {string}\n\t */\n\tgroup_separator: string;\n\n\t/**\n\t * The maximum number of decimal places to allow.\n\t * @param {number}\n\t */\n\tprecision: number;\n\n\t/**\n\t * JSX Attribute for CSS classnames\n\t * @type {any}\n\t */\n\tclassName?: any;\n\n\t/**\n\t * JSX attribute for the input placeholder\n\t * @type {any}\n\t */\n\t placeholder?: any;\n\n\t/**\n\t * Callback function to receive changes in the number value.\n\t * @param {(value: number|undefined) => void}\n\t */\n\tdidChangeNumber?: (value: number|undefined) => void;\n};\n\ninterface IState {\n\t/**\n\t * The string to display in the textfield.\n\t * @type {string}\n\t */\n\tstring_value: string;\n};\n\ninterface IParseResult {\n\tstring_value: string;\n\tnumber_value: number|undefined;\n}\n\nconst initialState: IState = {\n\tstring_value: \"\",\n};\n\nexport default class NumberTextfield extends React.Component<IProps, IState> {\n\n\tpublic static defaultProps: IProps = {\n\t\tdecimal_character: \".\",\n\t\tgroup_separator: \",\",\n\t\tprecision: 2,\n\t};\n\n\tpublic state = initialState;\n\n\t/**\n\t * If a number is provided as a prop, this will create a new formatted string\n\t * for that number.\n\t * @param {IProps} nextProps\n\t * @param {IState} currState\n\t * @return {Partial<IState>|undefined}\n\t */\n\tpublic static derivedStateFromProps(nextProps: IProps, currState: IState): Partial<IState>|undefined {\n\t\tif (typeof nextProps.number === \"number\") {\n\t\t\treturn parseString(\n\t\t\t\tnextProps.number.toString(),\n\t\t\t\tnextProps.decimal_character,\n\t\t\t\tnextProps.group_separator,\n\t\t\t\tnextProps.precision\n\t\t\t);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tconstructor(props: IProps) {\n\t\tsuper(props);\n\n\t\t// precision must be a positive integer value.\n\t\tif (props.precision < 0 || props.precision % 1 !== 0) {\n\t\t\tthrow new Error(\"Maximum precision must be a positive integer.\");\n\t\t}\n\t}\n\n\tpublic render() {\n\t\treturn (\n\t\t\t<input\n\t\t\t\ttype=\"text\"\n\t\t\t\tclassName={ this.props.className }\n\t\t\t\tvalue={ this.state.string_value }\n\t\t\t\tplaceholder={ this.props.placeholder }\n\t\t\t\tonKeyPress={ this.handleKeyPress }\n\t\t\t\tonChange={ this.handleChange }\n\t\t\t/>\n\t\t);\n\t}\n\n\t/**\n\t * Event listener for the KeyPress event fired from the input control.\n\t * @param {React.KeyboardEvent<any>}\n\t * @return boolean\n\t */\n\tpublic handleKeyPress = (e: React.KeyboardEvent<any>) => {\n\t\tconst charCode = e.charCode;\n\t\tlet shouldCancel = false;\n\n\t\tif (!charCodeIsDigit(charCode)) {\n\t\t\tconst charString = String.fromCharCode(charCode);\n\n\t\t\t// If it is not a digit or a decimal character, cancel the key.\n\t\t\tif (charString !== this.props.decimal_character) {\n\t\t\t\tshouldCancel = true;\n\t\t\t} else {\n\t\t\t\t// If the input field does not allow decimals, or if we already typed one, cancel the key.\n\t\t\t\tif (this.props.precision === 0 || this.state.string_value.indexOf(this.props.decimal_character) > -1) {\n\t\t\t\t\tshouldCancel = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (shouldCancel) {\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t/**\n\t * Event listener for the change event fired from the input control.\n\t * @param {React.ChangeEvent<any>} e\n\t * @return void\n\t */\n\tpublic handleChange = (e: React.ChangeEvent<any>) => {\n\t\tconst parseResult = parseString(\n\t\t\te.target.value,\n\t\t\tthis.props.decimal_character,\n\t\t\tthis.props.group_separator,\n\t\t\tthis.props.precision\n\t\t);\n\n\t\tthis.setState({\n\t\t\tstring_value: parseResult.string_value,\n\t\t});\n\n\t\tif (typeof this.props.didChangeNumber === \"function\") {\n\t\t\tthis.props.didChangeNumber(parseResult.number_value);\n\t\t}\n\t}\n};\n\n/**\n * Parses a string as a number, and returns the number and formatting string.\n * @param {string} value\n * @param {string} decimalChar\n * @param {string} groupChar\n * @param {number} maxPrecision\n * @return {IParseResult}\n */\nfunction parseString(value: string, decimalChar: string, groupChar: string, maxPrecision: number): IParseResult {\n\tconst sanitzeRegExp = new RegExp(`[^0-9${ escapeRegExp(decimalChar) }]+`, \"g\");\n\tlet stringValue = value.replace(sanitzeRegExp, \"\").replace(decimalChar, \".\");\n\tlet numberValue = stringToNumber(stringValue);\n\n\t// If we could not find a number, reset the textfield.\n\tif (typeof numberValue === \"undefined\" || isNaN(numberValue)) {\n\t\tconsole.warn(\"String could not be represented as a number. Resetting textfield value.\");\n\t\treturn {\n\t\t\tnumber_value: undefined,\n\t\t\tstring_value: \"\",\n\t\t};\n\t}\n\n\t// If it exceeds the maximum precision, chop off excess digits.\n\tconst isDecimal = stringValue.indexOf(\".\") > -1;\n\tconst precision = countDecimalPrecision(stringValue);\n\tif (numberValue % 1 !== 0 && precision > maxPrecision) {\n\t\t// Exceeds precision, we cannot allow it.\n\t\tconsole.warn(\"Additional decimal digit will exceed maximum precision.\");\n\n\t\tconst roundingConstant = Math.pow(10, maxPrecision);\n\t\tnumberValue = Math.floor(numberValue * roundingConstant) / roundingConstant;\n\t}\n\n\t// Recreate a string value using the derived number\n\tstringValue = numberToString(\n\t\tnumberValue,\n\t\tgroupChar,\n\t\tdecimalChar,\n\t\tisDecimal ? Math.max(0, Math.min(precision, maxPrecision)) : -1\n\t);\n\n\treturn {\n\t\tnumber_value: numberValue,\n\t\tstring_value: stringValue,\n\t};\n}\n\n/**\n * Returns the numerical representation of a number.\n * @param {string} value\n * @return number|undefined\n */\nfunction stringToNumber(value: string): number|undefined {\n\tlet numberValue: number|undefined = undefined;\n\t\n\t// If we have a decimal dot in the string, then it is a floating point number.\n\tconst isDecimal: boolean = value.indexOf(\".\") > -1;\n\n\t// If it is a floating point number, make sure we have at least one whole number.\n\t// Assume zero if nothing is there.\n\tif (isDecimal && value.length === 1) {\n\t\tvalue = \"0\" + value;\n\t}\n\n\t// If it has the decimal character, we will parse the string as a decimal value.\n\tif (isDecimal) {\n\t\tnumberValue = parseFloat(value);\n\t} else {\n\t\tnumberValue = parseInt(value);\n\t}\n\n\treturn numberValue;\n}\n\n/**\n * Returns a string representation of a number given a specific group character and decimal character.\n * Providing -1 for precision will remove the decimal point altogether.\n * Providing 0 for precision will add just the decimal point.\n * Any positive number will add the decimal values and pad with zeroes.\n * @param {number} value\n * @param {string} groupChar\n * @param {string} decimalChar\n * @param {number} precision\n * @return string\n */\nfunction numberToString(value: number, groupChar: string, decimalChar: string, precision: number): string {\n\tconst stringValueParts = value.toString().split(\".\");\n\tconst integerString = stringValueParts[0];\n\tconst decimalString = stringValueParts.length > 1 ? stringValueParts[1] : \"\";\n\tconst numGroups = Math.floor(integerString.length / 3);\n\tlet formattedString: string = \"\";\n\n\t// Add the whole integer values, separated by every 3 numbers with the groupChar\n\tif (numGroups > 0) {\n\t\tfor (let i = 1; i <= numGroups; i++) {\n\t\t\tformattedString = integerString.substr(i * -3, 3) + (i > 1 ? groupChar + formattedString : \"\");\n\t\t}\n\t}\n\n\t// Add the remaining integers that didn't fall into a group of 3\n\tconst integerRemainder = integerString.length % 3;\n\tif (integerRemainder > 0) {\n\t\tformattedString = integerString.substr(0, integerRemainder) + (formattedString.length > 0 ? groupChar + formattedString : \"\");\n\t}\n\n\t// If we are including decimal values, add the decimal character and the decimal string values.\n\t// Fill in 0s for any remaining precision.\n\tif (precision > -1) {\n\t\tformattedString += decimalChar + decimalString;\n\t\tif (precision > decimalString.length) {\n\t\t\tformattedString += (new Array(precision - decimalString.length)).fill(0).join(\"\");\n\t\t}\n\t}\n\n\treturn formattedString;\n}\n\n/**\n * Returns the precision (number of decimal places) in a numberical string.\n * @param {number} value\n * @param {string} decimalChar The character used for a decimal.\n * @return {number}\n */\nfunction countDecimalPrecision(value: string): number {\n\tconst stringParts = value.toString().split(\".\");\n\tif (stringParts.length > 1) {\n\t\treturn stringParts[1].length;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Escapes certain characters in a string and prepares it for use as a regular expression.\n * @see https://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex/6969486#6969486\n * @param {string} str\n * @return {string}\n */\nfunction escapeRegExp(str: string): string {\n\treturn str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\n\n/**\n * Whether or not a given character code maps to a decimal digit (0-9).\n * @return {boolean}\n */\nfunction charCodeIsDigit(charCode: number): boolean {\n\treturn charCode >= 48 && charCode <= 57;\n}\n"],"sourceRoot":""}